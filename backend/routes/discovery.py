"""
Discovery API routes
Handles AI-powered product discovery and candidate management
"""
from flask import Blueprint, request, jsonify
from datetime import datetime
from sqlalchemy import desc
import logging

from models import get_db, ProductCandidate, CandidateStatus
from ai.discovery_service import get_discovery_service

bp = Blueprint('discovery', __name__)
logger = logging.getLogger(__name__)


@bp.route('/discovery/start', methods=['POST'])
def start_discovery():
    """
    Start AI product discovery

    Body: {
        category: string,  # fashion, electronics, home, etc
        keyword_count: number,  # optional, default 5
        products_per_keyword: number,  # optional, default 10
        min_score: number  # optional, default 70
    }
    """
    try:
        data = request.get_json(force=True) or {}

        category = data.get('category', 'fashion')
        keyword_count = int(data.get('keyword_count', 5))
        products_per_keyword = int(data.get('products_per_keyword', 10))
        min_score = float(data.get('min_score', 70))

        logger.info(f"üöÄ Starting discovery: category={category}, keywords={keyword_count}")

        # Get discovery service
        discovery = get_discovery_service()

        # Run discovery
        results = discovery.discover_products(
            category=category,
            keyword_count=keyword_count,
            products_per_keyword=products_per_keyword,
            min_score=min_score
        )

        return jsonify({
            'ok': True,
            'data': results
        }), 200

    except Exception as e:
        logger.error(f"‚ùå Discovery failed: {str(e)}")
        return jsonify({
            'ok': False,
            'error': {
                'code': 'DISCOVERY_ERROR',
                'message': 'Failed to discover products',
                'details': {'error': str(e)}
            }
        }), 500


@bp.route('/discovery/keyword', methods=['POST'])
def discover_by_keyword():
    """
    Discover products for a specific keyword

    Body: {
        keyword: string,
        max_products: number,  # optional, default 20
        min_score: number  # optional, default 70
    }
    """
    try:
        data = request.get_json(force=True)

        keyword = data.get('keyword')
        if not keyword:
            return jsonify({
                'ok': False,
                'error': {
                    'code': 'VALIDATION_ERROR',
                    'message': 'Missing required field: keyword',
                    'details': {}
                }
            }), 400

        max_products = int(data.get('max_products', 20))
        min_score = float(data.get('min_score', 70))

        logger.info(f"üîç Discovering by keyword: {keyword}")

        discovery = get_discovery_service()
        results = discovery.discover_by_keyword(
            keyword=keyword,
            max_products=max_products,
            min_score=min_score
        )

        return jsonify({
            'ok': True,
            'data': results
        }), 200

    except Exception as e:
        logger.error(f"‚ùå Keyword discovery failed: {str(e)}")
        return jsonify({
            'ok': False,
            'error': {
                'code': 'DISCOVERY_ERROR',
                'message': 'Failed to discover products by keyword',
                'details': {'error': str(e)}
            }
        }), 500


@bp.route('/candidates', methods=['GET'])
def get_candidates():
    """
    Get list of product candidates

    Query params:
        status: filter by status
        min_score: minimum AI score
        limit: page size (default 50)
        offset: page offset (default 0)
    """
    try:
        status_filter = request.args.get('status')
        min_score = request.args.get('min_score', type=float)
        limit = int(request.args.get('limit', 50))
        offset = int(request.args.get('offset', 0))

        with get_db() as db:
            # Build query
            query = db.query(ProductCandidate)

            # Apply filters
            if status_filter:
                query = query.filter(ProductCandidate.status == status_filter)

            if min_score is not None:
                query = query.filter(ProductCandidate.ai_score >= min_score)

            # Get total count
            total = query.count()

            # Sort by AI score desc and paginate
            candidates = query.order_by(desc(ProductCandidate.ai_score))\
                             .limit(limit)\
                             .offset(offset)\
                             .all()

            # Convert to dict
            candidates_data = [candidate.to_dict() for candidate in candidates]

            return jsonify({
                'ok': True,
                'data': {
                    'candidates': candidates_data,
                    'total': total,
                    'limit': limit,
                    'offset': offset
                }
            }), 200

    except Exception as e:
        logger.error(f"‚ùå Error fetching candidates: {str(e)}")
        return jsonify({
            'ok': False,
            'error': {
                'code': 'DATABASE_ERROR',
                'message': 'Failed to fetch candidates',
                'details': {'error': str(e)}
            }
        }), 500


@bp.route('/candidates/<candidate_id>', methods=['GET'])
def get_candidate(candidate_id):
    """Get single candidate by ID"""
    try:
        with get_db() as db:
            candidate = db.query(ProductCandidate).filter(
                ProductCandidate.id == candidate_id
            ).first()

            if not candidate:
                return jsonify({
                    'ok': False,
                    'error': {
                        'code': 'CANDIDATE_NOT_FOUND',
                        'message': f'Candidate {candidate_id} not found',
                        'details': {}
                    }
                }), 404

            return jsonify({
                'ok': True,
                'data': candidate.to_dict()
            }), 200

    except Exception as e:
        logger.error(f"‚ùå Error fetching candidate: {str(e)}")
        return jsonify({
            'ok': False,
            'error': {
                'code': 'DATABASE_ERROR',
                'message': 'Failed to fetch candidate',
                'details': {'error': str(e)}
            }
        }), 500


@bp.route('/candidates/<candidate_id>/approve', methods=['POST'])
def approve_candidate(candidate_id):
    """
    Approve a candidate for registration

    Body: {
        reviewed_by: string
    }
    """
    try:
        data = request.get_json(force=True) or {}

        with get_db() as db:
            candidate = db.query(ProductCandidate).filter(
                ProductCandidate.id == candidate_id
            ).first()

            if not candidate:
                return jsonify({
                    'ok': False,
                    'error': {
                        'code': 'CANDIDATE_NOT_FOUND',
                        'message': f'Candidate {candidate_id} not found',
                        'details': {}
                    }
                }), 404

            # Update status
            candidate.status = CandidateStatus.APPROVED.value
            candidate.reviewed_by = data.get('reviewed_by', 'system')
            candidate.reviewed_at = datetime.utcnow()

            db.commit()

            logger.info(f"‚úÖ Candidate approved: {candidate_id}")

            return jsonify({
                'ok': True,
                'data': {
                    'candidate_id': str(candidate.id),
                    'status': candidate.status,
                    'message': 'Candidate approved successfully'
                }
            }), 200

    except Exception as e:
        logger.error(f"‚ùå Error approving candidate: {str(e)}")
        return jsonify({
            'ok': False,
            'error': {
                'code': 'DATABASE_ERROR',
                'message': 'Failed to approve candidate',
                'details': {'error': str(e)}
            }
        }), 500


@bp.route('/candidates/<candidate_id>/reject', methods=['POST'])
def reject_candidate(candidate_id):
    """
    Reject a candidate

    Body: {
        reviewed_by: string,
        rejection_reason: string
    }
    """
    try:
        data = request.get_json(force=True) or {}

        with get_db() as db:
            candidate = db.query(ProductCandidate).filter(
                ProductCandidate.id == candidate_id
            ).first()

            if not candidate:
                return jsonify({
                    'ok': False,
                    'error': {
                        'code': 'CANDIDATE_NOT_FOUND',
                        'message': f'Candidate {candidate_id} not found',
                        'details': {}
                    }
                }), 404

            # Update status
            candidate.status = CandidateStatus.REJECTED.value
            candidate.reviewed_by = data.get('reviewed_by', 'system')
            candidate.reviewed_at = datetime.utcnow()
            candidate.rejection_reason = data.get('rejection_reason', '')

            db.commit()

            logger.info(f"‚ùå Candidate rejected: {candidate_id}")

            return jsonify({
                'ok': True,
                'data': {
                    'candidate_id': str(candidate.id),
                    'status': candidate.status,
                    'message': 'Candidate rejected'
                }
            }), 200

    except Exception as e:
        logger.error(f"‚ùå Error rejecting candidate: {str(e)}")
        return jsonify({
            'ok': False,
            'error': {
                'code': 'DATABASE_ERROR',
                'message': 'Failed to reject candidate',
                'details': {'error': str(e)}
            }
        }), 500


# ============================================================================
# Competitor Analysis - Naver Shopping API
# ============================================================================

@bp.route('/discovery/analyze-competitor', methods=['POST'])
def analyze_competitor():
    """
    ÎÑ§Ïù¥Î≤Ñ ÏáºÌïë Ïù∏Í∏∞ ÏÉÅÌíà Í≤ÄÏÉâ (Naver Shopping API ÏÇ¨Ïö©)

    Body: {
        keyword: string,  # Í≤ÄÏÉâ ÌÇ§ÏõåÎìú (Ïòà: "Ï≤≠Î∞îÏßÄ", "Îß®Ìà¨Îß®")
        max_products: number,  # ÏµúÎåÄ ÏÉÅÌíà Ïàò (Í∏∞Î≥∏ 100)
        min_price: number,  # ÏµúÏÜå Í∞ÄÍ≤© (ÏÑ†ÌÉù, Í∏∞Î≥∏ 0)
        max_price: number,  # ÏµúÎåÄ Í∞ÄÍ≤© (ÏÑ†ÌÉù, Í∏∞Î≥∏ 0)
        filter_smartstore: boolean  # Ïä§ÎßàÌä∏Ïä§ÌÜ†Ïñ¥Îßå ÌïÑÌÑ∞ÎßÅ (ÏÑ†ÌÉù, Í∏∞Î≥∏ false)
    }

    Response: {
        ok: true,
        data: {
            keyword: string,
            products: [{
                title: string,
                price: number,
                image_url: string,
                product_url: string,
                product_id: string,
                mall_name: string,
                brand: string,
                category1: string,
                category2: string,
                rank: number,
                popularity_score: number
            }],
            total_count: number
        }
    }
    """
    try:
        data = request.get_json(force=True) or {}

        keyword = data.get('keyword')
        if not keyword:
            return jsonify({
                'ok': False,
                'error': {
                    'code': 'VALIDATION_ERROR',
                    'message': 'Missing required field: keyword',
                    'details': {}
                }
            }), 400

        max_products = int(data.get('max_products', 100))
        min_price = int(data.get('min_price', 0))
        max_price = int(data.get('max_price', 0))
        filter_smartstore = data.get('filter_smartstore', False)

        logger.info(f"üîç Searching Naver Shopping: keyword='{keyword}', max={max_products}")

        # Import Naver Shopping API
        from connectors.naver_shopping_api import get_shopping_api

        shopping_api = get_shopping_api()
        products = shopping_api.search_popular_products(
            keyword=keyword,
            max_products=max_products,
            min_price=min_price,
            max_price=max_price
        )

        logger.info(f"‚úÖ Search complete: {len(products)} products found")

        return jsonify({
            'ok': True,
            'data': {
                'keyword': keyword,
                'products': products,
                'total_count': len(products)
            }
        }), 200

    except Exception as e:
        logger.error(f"‚ùå Product search failed: {str(e)}")
        return jsonify({
            'ok': False,
            'error': {
                'code': 'SEARCH_ERROR',
                'message': 'Failed to search products',
                'details': {'error': str(e)}
            }
        }), 500


@bp.route('/discovery/match-taobao-batch', methods=['POST'])
def match_taobao_batch():
    """
    Ïä§ÎßàÌä∏Ïä§ÌÜ†Ïñ¥ ÏÉÅÌíàÎì§Ïóê ÎåÄÌïú ÌÉÄÏò§Î∞îÏò§ Î∞∞Ïπò Îß§Ïπ≠

    Body: {
        products: [{
            title: string,
            price: number,
            image_url: string
        }],
        max_candidates: number  # Í∞Å ÏÉÅÌíàÎãπ ÌõÑÎ≥¥ Í∞úÏàò (Í∏∞Î≥∏ 3)
    }

    Response: {
        ok: true,
        data: {
            matches: [{
                smartstore_product: {...},
                taobao_candidates: [{
                    taobao_item_id: string,
                    title: string,
                    price: number,
                    currency: 'CNY',
                    image_url: string,
                    rating: number,
                    sold_count: number,
                    similarity_score: number,
                    taobao_url: string
                }],
                best_match: {...}
            }]
        }
    }
    """
    try:
        data = request.get_json(force=True) or {}

        products = data.get('products', [])
        if not products:
            return jsonify({
                'ok': False,
                'error': {
                    'code': 'VALIDATION_ERROR',
                    'message': 'Missing required field: products',
                    'details': {}
                }
            }), 400

        max_candidates = int(data.get('max_candidates', 3))

        logger.info(f"üîç Matching {len(products)} products with Taobao...")

        # Import services
        from ai.product_finder import get_product_finder
        from ai.translator import get_translator  # ÌïúÍ∏Ä ‚Üí Ï§ëÍµ≠Ïñ¥ Î≤àÏó≠

        product_finder = get_product_finder()
        translator = get_translator()
        matches = []

        for idx, product in enumerate(products, 1):
            try:
                title = product.get('title', '')
                logger.info(f"   [{idx}/{len(products)}] Matching: {title[:30]}...")

                # 1. ÌïúÍ∏Ä Ï†úÎ™© ‚Üí Ï§ëÍµ≠Ïñ¥ Î≤àÏó≠
                chinese_keyword = translator.translate_korean_to_chinese(title)
                logger.info(f"      Translated: {chinese_keyword}")

                # 2. ÌÉÄÏò§Î∞îÏò§ Í≤ÄÏÉâ
                taobao_results = product_finder.search_products(
                    keyword=chinese_keyword,
                    max_results=max_candidates * 2  # ÌïÑÌÑ∞ÎßÅ ÏúÑÌï¥ Ïó¨Ïú†ÏûàÍ≤å
                )

                # 3. Í∞ÄÍ≤© Î∞è ÌèâÏ†ê Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨
                # ÌèâÏ†ê ÎÜíÏùÄ Ïàú ‚Üí Í∞ÄÍ≤© ÎÇÆÏùÄ Ïàú
                sorted_results = sorted(
                    taobao_results,
                    key=lambda x: (-x.get('score', 0), x.get('price', 999999))
                )

                # 4. ÏÉÅÏúÑ NÍ∞ú ÏÑ†ÌÉù
                candidates = sorted_results[:max_candidates]

                # 5. ÌÉÄÏò§Î∞îÏò§ URL Ï∂îÍ∞Ä
                for candidate in candidates:
                    item_id = candidate.get('taobao_item_id')
                    if item_id:
                        candidate['taobao_url'] = f"https://item.taobao.com/item.htm?id={item_id}"

                matches.append({
                    'smartstore_product': product,
                    'taobao_candidates': candidates,
                    'best_match': candidates[0] if candidates else None
                })

            except Exception as e:
                logger.warning(f"   Failed to match product: {str(e)}")
                matches.append({
                    'smartstore_product': product,
                    'taobao_candidates': [],
                    'best_match': None,
                    'error': str(e)
                })

        logger.info(f"‚úÖ Taobao matching complete: {len(matches)} products")

        return jsonify({
            'ok': True,
            'data': {
                'matches': matches,
                'total_count': len(matches)
            }
        }), 200

    except Exception as e:
        logger.error(f"‚ùå Taobao matching failed: {str(e)}")
        return jsonify({
            'ok': False,
            'error': {
                'code': 'MATCHING_ERROR',
                'message': 'Failed to match with Taobao',
                'details': {'error': str(e)}
            }
        }), 500


@bp.route('/discovery/calculate-prices', methods=['POST'])
def calculate_prices():
    """
    Îß§Ïπ≠Îêú ÏÉÅÌíàÎì§Ïùò ÌåêÎß§Í∞Ä ÏûêÎèô Í≥ÑÏÇ∞

    Body: {
        matched_products: [{
            smartstore_product: {...},
            selected_taobao: {
                price: number,  # CNY
                title: string
            }
        }],
        target_margin: number  # Î™©Ìëú ÎßàÏßÑÏú® (Í∏∞Î≥∏ 0.35 = 35%)
    }

    Response: {
        ok: true,
        data: {
            products: [{
                ...matched_product,
                price_info: {
                    taobao_price_cny: number,
                    taobao_price_krw: number,
                    exchange_rate: number,
                    shipping_fee: number,
                    total_cost: number,
                    selling_price_rounded: number,
                    expected_profit: number,
                    actual_margin: number
                }
            }]
        }
    }
    """
    try:
        data = request.get_json(force=True) or {}

        matched_products = data.get('matched_products', [])
        if not matched_products:
            return jsonify({
                'ok': False,
                'error': {
                    'code': 'VALIDATION_ERROR',
                    'message': 'Missing required field: matched_products',
                    'details': {}
                }
            }), 400

        target_margin = float(data.get('target_margin', 0.35))

        logger.info(f"üí∞ Calculating prices for {len(matched_products)} products...")

        # Import calculator
        from utils.price_calculator import get_price_calculator

        price_calculator = get_price_calculator()
        results = []

        for product in matched_products:
            try:
                selected_taobao = product.get('selected_taobao') or product.get('best_match')
                if not selected_taobao:
                    logger.warning("   No selected taobao product, skipping...")
                    continue

                taobao_price_cny = float(selected_taobao.get('price', 0))
                title = selected_taobao.get('title', '')

                # Í∞ÄÍ≤© Í≥ÑÏÇ∞
                price_info = price_calculator.calculate_selling_price(
                    taobao_price_cny=taobao_price_cny,
                    title=title,
                    target_margin=target_margin
                )

                product['price_info'] = price_info
                results.append(product)

            except Exception as e:
                logger.warning(f"   Failed to calculate price: {str(e)}")
                continue

        logger.info(f"‚úÖ Price calculation complete: {len(results)} products")

        return jsonify({
            'ok': True,
            'data': {
                'products': results,
                'total_count': len(results)
            }
        }), 200

    except Exception as e:
        logger.error(f"‚ùå Price calculation failed: {str(e)}")
        return jsonify({
            'ok': False,
            'error': {
                'code': 'CALCULATION_ERROR',
                'message': 'Failed to calculate prices',
                'details': {'error': str(e)}
            }
        }), 500


@bp.route('/discovery/export-excel', methods=['POST'])
def export_excel():
    """
    ÏÑ†ÌÉùÎêú ÏÉÅÌíàÎì§ÏùÑ ÏóëÏÖÄÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞

    Body: {
        products: [{
            title: string,
            price: number,  # ÌåêÎß§Í∞Ä
            images: [string],
            taobao_item_id: string,
            taobao_url: string,
            taobao_price_cny: number,
            shipping_fee: number,
            total_cost: number,
            expected_profit: number,
            actual_margin: number,
            origin: string,
            category: string
        }],
        format: 'xlsx' | 'csv'  # Í∏∞Î≥∏ 'xlsx'
    }

    Response:
        ÏóëÏÖÄ/CSV ÌååÏùº Îã§Ïö¥Î°úÎìú
    """
    try:
        data = request.get_json(force=True) or {}

        products = data.get('products', [])
        if not products:
            return jsonify({
                'ok': False,
                'error': {
                    'code': 'VALIDATION_ERROR',
                    'message': 'Missing required field: products',
                    'details': {}
                }
            }), 400

        file_format = data.get('format', 'xlsx')

        logger.info(f"üìä Generating {file_format.upper()} for {len(products)} products...")

        # Import generator
        from utils.excel_generator import get_excel_generator
        from flask import send_file

        excel_generator = get_excel_generator()

        # Generate file
        if file_format == 'csv':
            filepath = excel_generator.generate_csv(products)
            mimetype = 'text/csv'
            download_name = os.path.basename(filepath)
        else:
            filepath = excel_generator.generate_excel(products)
            mimetype = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
            download_name = os.path.basename(filepath)

        logger.info(f"‚úÖ File generated: {filepath}")

        return send_file(
            filepath,
            as_attachment=True,
            download_name=download_name,
            mimetype=mimetype
        )

    except Exception as e:
        logger.error(f"‚ùå Excel export failed: {str(e)}")
        return jsonify({
            'ok': False,
            'error': {
                'code': 'EXPORT_ERROR',
                'message': 'Failed to export excel',
                'details': {'error': str(e)}
            }
        }), 500


# ============================================================================
# Product Translation - AI Translation Service
# ============================================================================

@bp.route('/discovery/translate-title', methods=['POST'])
def translate_title():
    """
    ÌÉÄÏò§Î∞îÏò§ ÏÉÅÌíà Ï†úÎ™© AI Î≤àÏó≠ (Ï§ëÍµ≠Ïñ¥ ‚Üí ÌïúÍ∏Ä)

    Body: {
        title: string,  # Ï§ëÍµ≠Ïñ¥ Ï†úÎ™©
        style: string  # optional: "formal", "casual", "seo" (Í∏∞Î≥∏: "marketing")
    }

    Response: {
        ok: true,
        data: {
            original: string,  # ÏõêÎ≥∏ Ï§ëÍµ≠Ïñ¥
            translated: string,  # Î≤àÏó≠Îêú ÌïúÍ∏Ä
            style: string  # ÏÇ¨Ïö©Îêú Ïä§ÌÉÄÏùº
        }
    }
    """
    try:
        data = request.get_json(force=True) or {}

        title = data.get('title')
        if not title:
            return jsonify({
                'ok': False,
                'error': {
                    'code': 'VALIDATION_ERROR',
                    'message': 'Missing required field: title',
                    'details': {}
                }
            }), 400

        style = data.get('style', 'marketing')

        logger.info(f"üîÑ Translating title (style: {style}): {title[:50]}...")

        # Import translator
        from ai.translator import get_translator

        translator = get_translator()
        translated = translator.translate_product_title(title)

        if not translated:
            return jsonify({
                'ok': False,
                'error': {
                    'code': 'TRANSLATION_ERROR',
                    'message': 'Translation service unavailable or failed',
                    'details': {'hint': 'Check GEMINI_API_KEY configuration'}
                }
            }), 500

        logger.info(f"‚úÖ Translation complete: {translated[:50]}...")

        return jsonify({
            'ok': True,
            'data': {
                'original': title,
                'translated': translated,
                'style': style
            }
        }), 200

    except Exception as e:
        logger.error(f"‚ùå Translation failed: {str(e)}")
        return jsonify({
            'ok': False,
            'error': {
                'code': 'TRANSLATION_ERROR',
                'message': 'Failed to translate title',
                'details': {'error': str(e)}
            }
        }), 500


@bp.route('/discovery/translate-batch', methods=['POST'])
def translate_batch():
    """
    Ïó¨Îü¨ ÏÉÅÌíà Ï†úÎ™© ÏùºÍ¥Ñ Î≤àÏó≠

    Body: {
        titles: [string],  # Ï§ëÍµ≠Ïñ¥ Ï†úÎ™© Î∞∞Ïó¥
        style: string  # optional
    }

    Response: {
        ok: true,
        data: {
            translations: [{
                original: string,
                translated: string,
                index: number
            }],
            total: number,
            failed: number
        }
    }
    """
    try:
        data = request.get_json(force=True) or {}

        titles = data.get('titles', [])
        if not titles:
            return jsonify({
                'ok': False,
                'error': {
                    'code': 'VALIDATION_ERROR',
                    'message': 'Missing required field: titles',
                    'details': {}
                }
            }), 400

        style = data.get('style', 'marketing')

        logger.info(f"üîÑ Batch translating {len(titles)} titles...")

        from ai.translator import get_translator

        translator = get_translator()
        translations = []
        failed_count = 0

        for idx, title in enumerate(titles):
            try:
                translated = translator.translate_product_title(title)
                if translated:
                    translations.append({
                        'original': title,
                        'translated': translated,
                        'index': idx
                    })
                else:
                    failed_count += 1
                    logger.warning(f"   [{idx+1}/{len(titles)}] Translation failed")
            except Exception as e:
                failed_count += 1
                logger.warning(f"   [{idx+1}/{len(titles)}] Error: {str(e)}")

        logger.info(f"‚úÖ Batch translation complete: {len(translations)}/{len(titles)} succeeded")

        return jsonify({
            'ok': True,
            'data': {
                'translations': translations,
                'total': len(titles),
                'succeeded': len(translations),
                'failed': failed_count
            }
        }), 200

    except Exception as e:
        logger.error(f"‚ùå Batch translation failed: {str(e)}")
        return jsonify({
            'ok': False,
            'error': {
                'code': 'TRANSLATION_ERROR',
                'message': 'Failed to translate titles',
                'details': {'error': str(e)}
            }
        }), 500
